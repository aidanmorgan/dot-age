using System.CommandLine;
using System.Text;
using DotAge.Core;
using DotAge.Core.Crypto;
using DotAge.Core.Recipients;
using DotAge.Core.Utils;
using Microsoft.Extensions.Logging;

namespace DotAge.Cli;

/// <summary>
///     Entry point for the DotAge CLI application.
/// </summary>
public class Program
{
    private const string UsageDescription = @"Usage:
    dotage [--encrypt] (-r RECIPIENT | -R PATH)... [--armor] [-o OUTPUT] [INPUT]
    dotage [--encrypt] --passphrase [--armor] [-o OUTPUT] [INPUT]
    dotage --decrypt [-i PATH]... [-o OUTPUT] [INPUT]

INPUT defaults to standard input, and OUTPUT defaults to standard output.
If OUTPUT exists, it will be overwritten.

RECIPIENT can be an age public key generated by age-keygen (""age1..."")
or an SSH public key (""ssh-ed25519 AAAA..."", ""ssh-rsa AAAA..."").

Recipient files contain one or more recipients, one per line. Empty lines
and lines starting with ""#"" are ignored as comments. ""-"" may be used to
read recipients from standard input.

Identity files contain one or more secret keys (""AGE-SECRET-KEY-1...""),
one per line, or an SSH key. Empty lines and lines starting with ""#"" are
ignored as comments. Passphrase encrypted age files can be used as
identity files. Multiple key files can be provided, and any unused ones
will be ignored. ""-"" may be used to read identities from standard input.

When --encrypt is specified explicitly, -i can also be used to encrypt to an
identity file symmetrically, instead or in addition to normal recipients.

Example:
    $ dotage-keygen -o key.txt
    Public key: age1ql3z7hjy54pw3hyww5ayyfg7zqgvc7w3j2elw8zmrj2kg5sfn9aqmcac8p
    $ tar cvz ~/data | dotage -r age1ql3z7hjy54pw3hyww5ayyfg7zqgvc7w3j2elw8zmrj2kg5sfn9aqmcac8p > data.tar.gz.age
    $ dotage --decrypt -i key.txt -o data.tar.gz data.tar.gz.age";

    /// <summary>
    ///     Creates a logger factory with console logging.
    /// </summary>
    /// <returns>A configured logger factory.</returns>
    private static ILoggerFactory CreateLoggerFactory()
    {
        return LoggerFactory.Create(builder => builder.AddConsole().SetMinimumLevel(LogLevel.Information));
    }


    /// <summary>
    ///     Application entry point.
    /// </summary>
    /// <param name="args">Command line arguments.</param>
    /// <returns>Exit code.</returns>
    public static async Task<int> Main(string[] args)
    {
        var program = new Program();
        return await program.RunAsync(args);
    }

    /// <summary>
    ///     Runs the application asynchronously with the specified arguments.
    /// </summary>
    /// <param name="args">Command line arguments.</param>
    /// <returns>Exit code.</returns>
    public async Task<int> RunAsync(string[] args)
    {
        ArgumentNullException.ThrowIfNull(args);

        // Use default logger for console
        using var loggerFactory = CreateLoggerFactory();
        var logger = loggerFactory.CreateLogger($"{nameof(Program)}");

        // Create commands
        var rootCommand = new RootCommand("Encrypt or decrypt files using the age format")
        {
            CreateEncryptCommand(logger),
            CreateDecryptCommand(logger)
        };

        rootCommand.Description = UsageDescription;

        // Parse arguments
        var parseResult = rootCommand.Parse(args);

        // Special handling for help flags: always print help and return 0
        if (args.Contains("-h") || args.Contains("--help"))
        {
            await rootCommand.InvokeAsync(new[] { "--help" });
            return 0;
        }

        // Check for unknown tokens and treat them as errors (like age CLI)
        if (parseResult.UnmatchedTokens.Count > 0)
        {
            logger.LogError($"Flag provided but not defined: {string.Join(", ", parseResult.UnmatchedTokens)}");
            return 2;
        }

        return await rootCommand.InvokeAsync(args);
    }


    /// <summary>
    ///     Creates the encrypt command.
    /// </summary>
    /// <param name="logger">Logger instance.</param>
    /// <returns>The encrypt command.</returns>
    private Command CreateEncryptCommand(ILogger logger)
    {
        var encryptOption = new Option<bool>(new[] { "-e", "--encrypt" },
            "Encrypt the input to the output. Default if omitted.");
        var armorOption = new Option<bool>(new[] { "-a", "--armor" },
            "Encrypt to a PEM encoded format.");
        var passphraseOption = new Option<bool>(new[] { "-p", "--passphrase" },
            "Encrypt with a passphrase.");
        var recipientOption = new Option<string[]>(new[] { "-r", "--recipient" },
            "Encrypt to the specified RECIPIENT. Can be repeated.");
        var recipientsFileOption = new Option<string[]>(new[] { "-R", "--recipients-file" },
            "Encrypt to recipients listed at PATH. Can be repeated.");
        var identityOption = new Option<string[]>(new[] { "-i", "--identity" },
            "Use the identity file at PATH. Can be repeated.");
        var outputOption = new Option<string>(new[] { "-o", "--output" },
            "Write the result to the file at path OUTPUT.");
        var inputArgument = new Argument<string?>("input",
            "Input file (defaults to standard input)");

        var encryptCommand = new Command("encrypt", "Encrypt the input to the output")
        {
            encryptOption,
            armorOption,
            passphraseOption,
            recipientOption,
            recipientsFileOption,
            identityOption,
            outputOption,
            inputArgument
        };

        encryptCommand.SetHandler(
            async (encryptFlag, armorFlag, passphraseFlag, recipientFlags, recipientsFileFlags, identityFlags,
                    outputFlag, inputArg) =>
                await HandleEncryptAsync(encryptFlag, armorFlag, passphraseFlag, recipientFlags, recipientsFileFlags,
                    identityFlags, outputFlag, inputArg, logger),
            encryptOption,
            armorOption,
            passphraseOption,
            recipientOption,
            recipientsFileOption,
            identityOption,
            outputOption,
            inputArgument
        );

        return encryptCommand;
    }

    /// <summary>
    ///     Creates the decrypt command.
    /// </summary>
    /// <param name="logger">Logger instance.</param>
    /// <returns>The decrypt command.</returns>
    private Command CreateDecryptCommand(ILogger logger)
    {
        var decryptOption = new Option<bool>(new[] { "-d", "--decrypt" },
            "Decrypt the input to the output.");
        var passphraseOption = new Option<bool>(new[] { "-p", "--passphrase" },
            "Decrypt with a passphrase.");
        var identityOption = new Option<string[]>(new[] { "-i", "--identity" },
            "Use the identity file at PATH. Can be repeated.");
        var outputOption = new Option<string>(new[] { "-o", "--output" },
            "Write the result to the file at path OUTPUT.");
        var inputArgument = new Argument<string?>("input",
            "Input file (defaults to standard input)");

        var decryptCommand = new Command("decrypt", "Decrypt the input to the output")
        {
            decryptOption,
            passphraseOption,
            identityOption,
            outputOption,
            inputArgument
        };

        decryptCommand.SetHandler(
            async (decryptFlag, passphraseFlag, identityFlags, outputFlag, inputArg) =>
                await HandleDecryptAsync(decryptFlag, passphraseFlag, identityFlags, outputFlag, inputArg, logger),
            decryptOption,
            passphraseOption,
            identityOption,
            outputOption,
            inputArgument
        );

        return decryptCommand;
    }

    /// <summary>
    ///     Handles the encrypt command.
    /// </summary>
    private async Task<int> HandleEncryptAsync(
        bool encryptFlag,
        bool armorFlag,
        bool passphraseFlag,
        string[]? recipientFlags,
        string[]? recipientsFileFlags,
        string[]? identityFlags,
        string? outputFlag,
        string? inputArg,
        ILogger logger)
    {
        try
        {
            if (armorFlag)
                logger.LogWarning("Armor format is not yet implemented");

            // Validate input parameters
            if (!ValidateEncryptionParameters(passphraseFlag, recipientFlags, recipientsFileFlags, identityFlags,
                    logger))
                return 1;

            // Create Age instance and configure recipients
            var age = new Age();

            if (passphraseFlag)
            {
                if (!ConfigurePassphraseEncryption(age, logger))
                    return 1;
            }
            else
            {
                // Add recipients from various sources
                if (!ConfigureRecipients(age, recipientFlags, recipientsFileFlags, identityFlags, logger))
                    return 1;
            }

            // Read input data
            byte[] inputData;
            try
            {
                inputData = await ReadInputDataAsync(inputArg, logger);
            }
            catch (Exception ex)
            {
                logger.LogError(ex.Message);
                return 1;
            }

            // Encrypt the data
            var encryptedData = age.Encrypt(inputData);

            // Write the output
            await WriteOutputDataAsync(encryptedData, outputFlag);

            return 0;
        }
        catch (Exception ex)
        {
            logger.LogError(ex, "Encryption failed");
            return 1;
        }
    }

    /// <summary>
    ///     Validates encryption parameters to ensure they are valid.
    /// </summary>
    /// <returns>True if parameters are valid, false otherwise.</returns>
    private bool ValidateEncryptionParameters(
        bool passphraseFlag,
        string[]? recipientFlags,
        string[]? recipientsFileFlags,
        string[]? identityFlags,
        ILogger logger)
    {
        // Validate that we have at least one recipient or passphrase
        var hasRecipients =
            recipientFlags?.Length > 0 ||
            recipientsFileFlags?.Length > 0 ||
            identityFlags?.Length > 0;

        if (!hasRecipients && !passphraseFlag)
        {
            logger.LogError("No recipients specified. Use -r, -R, -i, or -p to specify recipients.");
            return false;
        }

        // Validate that passphrase is not combined with other recipients
        if (passphraseFlag && hasRecipients)
        {
            logger.LogError("Passphrase encryption cannot be combined with other recipients.");
            return false;
        }

        return true;
    }

    /// <summary>
    ///     Configures passphrase encryption by prompting for a passphrase and adding a ScryptRecipient.
    /// </summary>
    /// <returns>True if successful, false otherwise.</returns>
    private bool ConfigurePassphraseEncryption(Age age, ILogger logger)
    {
        var passphrase = PromptForPassphrase(logger);
        if (string.IsNullOrEmpty(passphrase))
        {
            logger.LogError("Passphrase cannot be empty");
            return false;
        }

        age.AddRecipient(new ScryptRecipient(passphrase));
        return true;
    }

    /// <summary>
    ///     Configures recipients from command line arguments, recipient files, and identity files.
    /// </summary>
    /// <returns>True if successful, false otherwise.</returns>
    private bool ConfigureRecipients(
        Age age,
        string[]? recipientFlags,
        string[]? recipientsFileFlags,
        string[]? identityFlags,
        ILogger logger)
    {
        // Add recipients from command line arguments
        if (recipientFlags?.Length > 0)
            if (!AddRecipientsFromCommandLine(age, recipientFlags, logger))
                return false;

        // Add recipients from recipient files
        if (recipientsFileFlags?.Length > 0)
            if (!AddRecipientsFromFiles(age, recipientsFileFlags, logger))
                return false;

        // Add recipients from identity files
        if (identityFlags?.Length > 0)
            if (!AddRecipientsFromIdentityFiles(age, identityFlags, logger))
                return false;

        return true;
    }

    /// <summary>
    ///     Adds recipients from command line arguments.
    /// </summary>
    /// <returns>True if successful, false otherwise.</returns>
    private bool AddRecipientsFromCommandLine(Age age, string[] recipientFlags, ILogger logger)
    {
        foreach (var recipient in recipientFlags)
            try
            {
                var publicKey = KeyFileUtils.DecodeAgePublicKey(recipient);
                age.AddRecipient(new X25519Recipient(publicKey));
            }
            catch (Exception ex)
            {
                logger.LogError($"Invalid recipient '{recipient}': {ex.Message}");
                return false;
            }

        return true;
    }

    /// <summary>
    ///     Adds recipients from recipient files.
    /// </summary>
    /// <returns>True if successful, false otherwise.</returns>
    private bool AddRecipientsFromFiles(Age age, string[] recipientsFileFlags, ILogger logger)
    {
        foreach (var recipientsFile in recipientsFileFlags)
        {
            if (!File.Exists(recipientsFile))
            {
                logger.LogError($"Recipients file not found: {recipientsFile}");
                return false;
            }

            try
            {
                var recipients = KeyFileUtils.ReadRecipientsFile(recipientsFile);
                foreach (var recipient in recipients)
                {
                    var publicKey = KeyFileUtils.DecodeAgePublicKey(recipient);
                    age.AddRecipient(new X25519Recipient(publicKey));
                }
            }
            catch (Exception ex)
            {
                logger.LogError($"Error reading recipients file '{recipientsFile}': {ex.Message}");
                return false;
            }
        }

        return true;
    }

    /// <summary>
    ///     Adds recipients from identity files.
    /// </summary>
    /// <returns>True if successful, false otherwise.</returns>
    private bool AddRecipientsFromIdentityFiles(Age age, string[] identityFlags, ILogger logger)
    {
        foreach (var identityFile in identityFlags)
        {
            if (!File.Exists(identityFile))
            {
                logger.LogError($"Identity file not found: {identityFile}");
                return false;
            }

            try
            {
                var (privateKeyBytes, _) = KeyFileUtils.ParseKeyFileAsBytes(identityFile);
                var publicKeyBytes = X25519.GetPublicKeyFromPrivateKey(privateKeyBytes);
                age.AddRecipient(new X25519Recipient(publicKeyBytes));
            }
            catch (Exception ex)
            {
                logger.LogError($"Error reading identity file '{identityFile}': {ex.Message}");
                return false;
            }
        }

        return true;
    }

    /// <summary>
    ///     Handles the decrypt command.
    /// </summary>
    /// <param name="decryptFlag">Flag indicating decryption mode.</param>
    /// <param name="identityFlags">Identity files to use for decryption.</param>
    /// <param name="outputFlag">Output file path.</param>
    /// <param name="inputArg">Input file path.</param>
    /// <param name="logger">Logger instance.</param>
    /// <returns>Exit code.</returns>
    private async Task<int> HandleDecryptAsync(
        bool decryptFlag,
        bool passphraseFlag,
        string[]? identityFlags,
        string? outputFlag,
        string? inputArg,
        ILogger logger)
    {
        try
        {
            // Read input data
            byte[] inputData;
            try
            {
                inputData = await ReadInputDataAsync(inputArg, logger);
            }
            catch (Exception ex)
            {
                logger.LogError(ex.Message);
                return 1;
            }

            // Create Age instance and configure identities
            var age = new Age();

            // Check if the file is passphrase-encrypted
            var isPassphraseEncrypted = Age.IsPassphraseEncrypted(inputData);

            if (isPassphraseEncrypted)
            {
                if (!ConfigurePassphraseDecryption(age, logger))
                    return 1;
            }
            else
            {
                // Validate identity flags
                if (!ValidateIdentityFlags(identityFlags, logger))
                    return 1;

                // Add identities from files
                if (!AddIdentitiesFromFilesAsync(age, identityFlags!, logger))
                    return 1;
            }

            // Decrypt the data
            byte[] decryptedData;
            try
            {
                decryptedData = age.Decrypt(inputData);
            }
            catch (Exception ex)
            {
                logger.LogError($"Decryption failed: {ex.Message}");
                return 1;
            }

            // Write the output
            await WriteOutputDataAsync(decryptedData, outputFlag);

            return 0;
        }
        catch (Exception ex)
        {
            logger.LogError(ex, "Decryption failed");
            return 1;
        }
    }

    /// <summary>
    ///     Validates that identity flags are provided when needed.
    /// </summary>
    /// <param name="identityFlags">Identity flags to validate.</param>
    /// <param name="logger">Logger instance.</param>
    /// <returns>True if valid, false otherwise.</returns>
    private bool ValidateIdentityFlags(string[]? identityFlags, ILogger logger)
    {
        if (identityFlags == null || identityFlags.Length == 0)
        {
            logger.LogError("No identities specified. Use -i to specify identity files.");
            return false;
        }

        return true;
    }

    /// <summary>
    ///     Configures passphrase decryption by prompting for a passphrase.
    /// </summary>
    /// <param name="age">Age instance to configure.</param>
    /// <param name="logger">Logger instance.</param>
    /// <returns>True if successful, false otherwise.</returns>
    private bool ConfigurePassphraseDecryption(Age age, ILogger logger)
    {
        var passphrase = PromptForDecryptionPassphrase();
        if (string.IsNullOrEmpty(passphrase))
        {
            logger.LogError("Passphrase cannot be empty");
            return false;
        }

        age.AddIdentity(new ScryptIdentity(passphrase));
        return true;
    }

    /// <summary>
    ///     Adds identities from identity files to the Age instance.
    /// </summary>
    /// <param name="age">The Age instance to add identities to.</param>
    /// <param name="identityFiles">Array of identity file paths.</param>
    /// <param name="logger">Logger instance.</param>
    /// <returns>True if all identities were added successfully, false otherwise.</returns>
    /// <exception cref="ArgumentNullException">Thrown when age or identityFiles is null.</exception>
    private bool AddIdentitiesFromFilesAsync(Age age, string[] identityFiles, ILogger logger)
    {
        ArgumentNullException.ThrowIfNull(age);
        ArgumentNullException.ThrowIfNull(identityFiles);
        ArgumentNullException.ThrowIfNull(logger);

        foreach (var identityFile in identityFiles)
        {
            if (string.IsNullOrEmpty(identityFile))
            {
                logger.LogError("Identity file path cannot be null or empty");
                return false;
            }

            if (!File.Exists(identityFile))
            {
                logger.LogError($"Identity file not found: {identityFile}");
                return false;
            }

            try
            {
                var (privateKeyBytes, publicKeyBytes) = KeyFileUtils.ParseKeyFileAsBytes(identityFile);
                age.AddIdentity(new X25519Recipient(privateKeyBytes, publicKeyBytes));
            }
            catch (Exception ex)
            {
                logger.LogError($"Error reading identity file '{identityFile}': {ex.Message}");
                return false;
            }
        }

        return true;
    }

    /// <summary>
    ///     Reads input data from a file or standard input.
    /// </summary>
    /// <param name="inputPath">Path to the input file, or null/"-" for standard input.</param>
    /// <param name="logger">Logger instance.</param>
    /// <returns>The read data as a byte array.</returns>
    /// <exception cref="ArgumentException">Thrown when inputPath starts with "-" but is not "-".</exception>
    /// <exception cref="FileNotFoundException">Thrown when the input file does not exist.</exception>
    private async Task<byte[]> ReadInputDataAsync(string? inputPath, ILogger logger)
    {
        ArgumentNullException.ThrowIfNull(logger);

        // Read from standard input if path is null, empty, or "-"
        if (string.IsNullOrEmpty(inputPath) || inputPath == "-")
        {
            using var stdin = Console.OpenStandardInput();
            using var ms = new MemoryStream();
            await stdin.CopyToAsync(ms);
            return ms.ToArray();
        }

        // Validate that the input file exists and is not a flag
        if (inputPath.StartsWith("-", StringComparison.Ordinal))
            throw new ArgumentException($"Invalid argument: {inputPath}. Did you mean to specify an input file?");

        if (!File.Exists(inputPath)) throw new FileNotFoundException($"Input file not found: {inputPath}");

        return await File.ReadAllBytesAsync(inputPath);
    }

    /// <summary>
    ///     Writes output data to a file or standard output.
    /// </summary>
    /// <param name="data">The data to write.</param>
    /// <param name="outputPath">Path to the output file, or null/"-" for standard output.</param>
    /// <returns>A task representing the asynchronous operation.</returns>
    /// <exception cref="ArgumentNullException">Thrown when data is null.</exception>
    private async Task WriteOutputDataAsync(byte[] data, string? outputPath)
    {
        ArgumentNullException.ThrowIfNull(data);

        // Write to standard output if path is null, empty, or "-"
        if (string.IsNullOrEmpty(outputPath) || outputPath == "-")
        {
            await Console.OpenStandardOutput().WriteAsync(data);
            Console.WriteLine(); // Add newline to prevent shell prompt from appearing on same line
        }
        else
        {
            // Ensure directory exists
            var directory = Path.GetDirectoryName(outputPath);
            if (!string.IsNullOrEmpty(directory) && !Directory.Exists(directory)) Directory.CreateDirectory(directory);

            await File.WriteAllBytesAsync(outputPath, data);
        }
    }

    /// <summary>
    ///     Prompts the user for a passphrase for encryption.
    /// </summary>
    private string PromptForPassphrase(ILogger logger)
    {
        if (Console.IsInputRedirected)
        {
            // Read the passphrase from stdin (first line) for non-interactive mode
            var passphrase = Console.In.ReadLine() ?? string.Empty;
            if (string.IsNullOrEmpty(passphrase))
            {
                // Generate a secure passphrase using BIP39 wordlist like age does
                passphrase = GenerateSecurePassphrase();
                logger.LogTrace($"Using autogenerated passphrase: {passphrase}");
            }

            return passphrase;
        }

        Console.Write("Enter passphrase (leave empty to autogenerate a secure one): ");
        var interactivePassphrase = ReadSecret();

        if (string.IsNullOrEmpty(interactivePassphrase))
        {
            // Generate a secure passphrase using BIP39 wordlist like age does
            interactivePassphrase = GenerateSecurePassphrase();
            logger.LogTrace($"Using autogenerated passphrase: {interactivePassphrase}");
        }
        else
        {
            Console.Write("Confirm passphrase: ");
            var confirm = ReadSecret();
            if (interactivePassphrase != confirm)
            {
                logger.LogError("Passphrases didn't match");
                return string.Empty;
            }
        }

        return interactivePassphrase;
    }

    /// <summary>
    ///     Prompts the user for a passphrase for decryption.
    /// </summary>
    private string PromptForDecryptionPassphrase()
    {
        if (Console.IsInputRedirected)
            // Read the passphrase from stdin (first line)
            return Console.In.ReadLine() ?? string.Empty;
        Console.Write("Enter passphrase: ");
        return ReadSecret();
    }

    /// <summary>
    ///     Generates a secure passphrase using the BIP39 wordlist.
    /// </summary>
    /// <returns>A secure passphrase consisting of 10 random words from the BIP39 wordlist.</returns>
    private string GenerateSecurePassphrase()
    {
        var words = new List<string>(10);

        // Generate 10 random words from the BIP39 wordlist (like age does)
        for (var i = 0; i < 10; i++) words.Add(Bip39Wordlist.GetRandomWord(null));

        return string.Join("-", words);
    }

    /// <summary>
    ///     Reads a secret (password/passphrase) from the console without displaying the input.
    /// </summary>
    /// <returns>The secret entered by the user.</returns>
    private string ReadSecret()
    {
        var passphrase = new StringBuilder(32);

        while (true)
        {
            var keyInfo = Console.ReadKey(true);

            switch (keyInfo.Key)
            {
                case ConsoleKey.Enter:
                    Console.WriteLine();
                    return passphrase.ToString();

                case ConsoleKey.Backspace:
                    if (passphrase.Length > 0)
                    {
                        passphrase.Remove(passphrase.Length - 1, 1);
                        Console.Write("\b \b");
                    }

                    break;

                case ConsoleKey.Escape:
                    // Clear the entire input
                    while (passphrase.Length > 0)
                    {
                        passphrase.Remove(passphrase.Length - 1, 1);
                        Console.Write("\b \b");
                    }

                    break;

                default:
                    // Only append printable characters
                    if (!char.IsControl(keyInfo.KeyChar))
                    {
                        passphrase.Append(keyInfo.KeyChar);
                        Console.Write("*");
                    }

                    break;
            }
        }
    }
}