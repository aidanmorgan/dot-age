using System;
using System.Diagnostics;
using System.IO;
using System.Text;
using System.Collections.Generic;
using DotAge.Core;
using DotAge.Core.Crypto;
using DotAge.Core.Recipients;
using DotAge.Core.Utils;
using Xunit;

namespace DotAge.Tests.Integration
{
    /// <summary>
    /// Builder class for Age integration tests to reduce code duplication.
    /// </summary>
    public class AgeTestBuilder : IDisposable
    {
        // Static properties for age executables
        private static readonly string AgeKeygenCommand;
        private static readonly string AgeCommand;

        // File paths
        private string _plaintextFile;
        private string _ciphertextFile;
        private string _decryptedFile;
        private string _keyFile;

        // Key information
        private string _privateKeyLine;
        private string _publicKeyLine;
        private byte[] _privateKey;
        private byte[] _publicKey;

        // Content
        private string _textContent;
        private byte[] _binaryContent;

        // Age instances
        private Age _encryptionAge;
        private Age _decryptionAge;

        // Flags
        private bool _useAgeKeygen;
        private bool _useDotAgeKeys;
        private bool _usePassphrase;
        private string _passphrase;

        // List of files to clean up
        private readonly List<string> _filesToCleanup = new List<string>();

        static AgeTestBuilder()
        {
            try
            {
                AgeKeygenCommand = FindAgeExecutable("age-keygen");
                AgeCommand = FindAgeExecutable("age");
            }
            catch (Exception)
            {
                // If we can't find the executables, set them to null
                // The tests will skip if they're null
                AgeKeygenCommand = null;
                AgeCommand = null;
            }
        }

        /// <summary>
        /// Creates a new instance of the AgeTestBuilder.
        /// </summary>
        public AgeTestBuilder()
        {
            // Initialize file paths
            _plaintextFile = Path.GetTempFileName();
            _ciphertextFile = Path.Combine(Path.GetTempPath(), Path.GetRandomFileName());
            _decryptedFile = Path.Combine(Path.GetTempPath(), Path.GetRandomFileName());
            _keyFile = Path.Combine(Path.GetTempPath(), Path.GetRandomFileName());

            // Add files to cleanup list
            _filesToCleanup.Add(_plaintextFile);
            _filesToCleanup.Add(_ciphertextFile);
            _filesToCleanup.Add(_decryptedFile);
            _filesToCleanup.Add(_keyFile);

            // Delete the files if they exist
            CleanupFiles();

            // Initialize Age instances
            _encryptionAge = new Age();
            _decryptionAge = new Age();
        }

        /// <summary>
        /// Checks if the age and age-keygen executables are available.
        /// </summary>
        /// <returns>True if both executables are available, false otherwise.</returns>
        public bool AreAgeExecutablesAvailable()
        {
            return AgeCommand != null && AgeKeygenCommand != null;
        }

        /// <summary>
        /// Checks if the age executable is available.
        /// </summary>
        /// <returns>True if the age executable is available, false otherwise.</returns>
        public bool IsAgeExecutableAvailable()
        {
            return AgeCommand != null;
        }

        /// <summary>
        /// Checks if the age-keygen executable is available.
        /// </summary>
        /// <returns>True if the age-keygen executable is available, false otherwise.</returns>
        public bool IsAgeKeygenExecutableAvailable()
        {
            return AgeKeygenCommand != null;
        }

        /// <summary>
        /// Configures the builder to use keys generated by age-keygen.
        /// </summary>
        /// <returns>The builder instance for method chaining.</returns>
        public AgeTestBuilder WithAgeKeygenGeneratedKeys()
        {
            if (AgeKeygenCommand == null)
            {
                throw new InvalidOperationException("age-keygen executable is not available");
            }

            _useAgeKeygen = true;
            _useDotAgeKeys = false;
            _usePassphrase = false;
            return this;
        }

        /// <summary>
        /// Configures the builder to use keys generated by DotAge.
        /// </summary>
        /// <returns>The builder instance for method chaining.</returns>
        public AgeTestBuilder WithDotAgeGeneratedKeys()
        {
            _useAgeKeygen = false;
            _useDotAgeKeys = true;
            _usePassphrase = false;
            return this;
        }

        /// <summary>
        /// Configures the builder to use a passphrase for encryption/decryption.
        /// </summary>
        /// <param name="passphrase">The passphrase to use.</param>
        /// <returns>The builder instance for method chaining.</returns>
        public AgeTestBuilder WithPassphrase(string passphrase)
        {
            _useAgeKeygen = false;
            _useDotAgeKeys = false;
            _usePassphrase = true;
            _passphrase = passphrase;
            return this;
        }

        /// <summary>
        /// Sets the text content to be encrypted/decrypted.
        /// </summary>
        /// <param name="content">The text content.</param>
        /// <returns>The builder instance for method chaining.</returns>
        public AgeTestBuilder WithTextContent(string content)
        {
            _textContent = content;
            _binaryContent = null;
            File.WriteAllText(_plaintextFile, content);
            return this;
        }

        /// <summary>
        /// Sets the binary content to be encrypted/decrypted.
        /// </summary>
        /// <param name="content">The binary content.</param>
        /// <returns>The builder instance for method chaining.</returns>
        public AgeTestBuilder WithBinaryContent(byte[] content)
        {
            _binaryContent = content;
            _textContent = null;
            File.WriteAllBytes(_plaintextFile, content);
            return this;
        }

        /// <summary>
        /// Creates a file with random binary data of the specified size.
        /// </summary>
        /// <param name="sizeInBytes">The size of the file in bytes.</param>
        /// <returns>The builder instance for method chaining.</returns>
        public AgeTestBuilder WithRandomBinaryContent(int sizeInBytes)
        {
            // Delete the existing plaintext file
            if (File.Exists(_plaintextFile))
            {
                File.Delete(_plaintextFile);
            }

            // Create a new random binary file
            _plaintextFile = CreateRandomBinaryFile(sizeInBytes);
            _filesToCleanup.Add(_plaintextFile);
            _binaryContent = File.ReadAllBytes(_plaintextFile);
            _textContent = null;
            return this;
        }

        /// <summary>
        /// Creates a file with text containing special characters.
        /// </summary>
        /// <returns>The builder instance for method chaining.</returns>
        public AgeTestBuilder WithSpecialCharactersContent()
        {
            // Delete the existing plaintext file
            if (File.Exists(_plaintextFile))
            {
                File.Delete(_plaintextFile);
            }

            // Create a new special characters file
            _plaintextFile = CreateSpecialCharactersFile();
            _filesToCleanup.Add(_plaintextFile);
            _textContent = File.ReadAllText(_plaintextFile);
            _binaryContent = null;
            return this;
        }

        /// <summary>
        /// Generates keys based on the configured key generation method.
        /// </summary>
        /// <returns>The builder instance for method chaining.</returns>
        public AgeTestBuilder GenerateKeys()
        {
            if (_useAgeKeygen)
            {
                // Generate a key pair using age-keygen
                RunProcess(AgeKeygenCommand, $"-o {_keyFile}");

                // Parse the key file using the utility method
                var (privateKeyLine, publicKey) = KeyFileUtils.ParseKeyFile(_keyFile);
                _privateKeyLine = privateKeyLine;
                _publicKeyLine = publicKey;
            }
            else if (_useDotAgeKeys)
            {
                // Generate a key pair using DotAge
                var keyPair = X25519.GenerateKeyPair();
                _privateKey = keyPair.privateKey;
                _publicKey = keyPair.publicKey;

                // Encode the keys in age format
                _privateKeyLine = X25519.EncodePrivateKey(_privateKey);
                _publicKeyLine = X25519.EncodePublicKey(_publicKey);

                // Write the keys to a file in the same format as age-keygen
                File.WriteAllText(_keyFile, $"{_privateKeyLine}\n# public key: {_publicKeyLine}");
            }
            else if (_usePassphrase)
            {
                // No key file needed for passphrase encryption
            }
            else
            {
                throw new InvalidOperationException("No key generation method configured");
            }

            return this;
        }

        /// <summary>
        /// Configures the Age instance for encryption.
        /// </summary>
        /// <returns>The builder instance for method chaining.</returns>
        public AgeTestBuilder ConfigureEncryption()
        {
            if (_useAgeKeygen || _useDotAgeKeys)
            {
                // Create a recipient from the public key
                IRecipient recipient;
                if (_useAgeKeygen)
                {
                    recipient = X25519Recipient.FromEncodedPublicKey(_publicKeyLine);
                }
                else
                {
                    recipient = new X25519Recipient(_publicKey);
                }
                _encryptionAge.AddRecipient(recipient);
            }
            else if (_usePassphrase)
            {
                // Create a scrypt recipient for passphrase encryption
                var recipient = new ScryptRecipient(_passphrase);
                _encryptionAge.AddRecipient(recipient);
            }
            else
            {
                throw new InvalidOperationException("No encryption method configured");
            }

            return this;
        }

        /// <summary>
        /// Configures the Age instance for decryption.
        /// </summary>
        /// <returns>The builder instance for method chaining.</returns>
        public AgeTestBuilder ConfigureDecryption()
        {
            if (_useAgeKeygen || _useDotAgeKeys)
            {
                // Create an identity from the private key
                IRecipient identity;
                if (_useAgeKeygen)
                {
                    identity = X25519Recipient.FromEncodedPrivateKey(_privateKeyLine);
                }
                else
                {
                    identity = new X25519Recipient(_publicKey, _privateKey);
                }
                _decryptionAge.AddIdentity(identity);
            }
            else if (_usePassphrase)
            {
                // Create a scrypt recipient for passphrase decryption
                var identity = new ScryptRecipient(_passphrase);
                _decryptionAge.AddIdentity(identity);
            }
            else
            {
                throw new InvalidOperationException("No decryption method configured");
            }

            return this;
        }

        /// <summary>
        /// Encrypts the plaintext file using DotAge.
        /// </summary>
        /// <returns>The builder instance for method chaining.</returns>
        public AgeTestBuilder EncryptWithDotAge()
        {
            _encryptionAge.EncryptFile(_plaintextFile, _ciphertextFile);
            return this;
        }


        /// <summary>
        /// Encrypts the plaintext file using the age command.
        /// </summary>
        /// <returns>The builder instance for method chaining.</returns>
        public AgeTestBuilder EncryptWithAge()
        {
            if (AgeCommand == null)
            {
                throw new InvalidOperationException("age executable is not available");
            }

            if (_useAgeKeygen || _useDotAgeKeys)
            {
                // Encrypt using the public key
                RunProcess(AgeCommand, $"-r \"{_publicKeyLine}\" -o {_ciphertextFile} {_plaintextFile}");
            }
            else if (_usePassphrase)
            {
                // Encrypt using the passphrase
                // For passphrase encryption, age expects the passphrase twice (once for confirmation)
                RunProcess(AgeCommand, $"-p -o {_ciphertextFile} {_plaintextFile}", $"{_passphrase}\n{_passphrase}");
            }
            else
            {
                throw new InvalidOperationException("No encryption method configured");
            }

            return this;
        }

        /// <summary>
        /// Decrypts the ciphertext file using DotAge.
        /// </summary>
        /// <returns>The builder instance for method chaining.</returns>
        public AgeTestBuilder DecryptWithDotAge()
        {
            _decryptionAge.DecryptFile(_ciphertextFile, _decryptedFile);
            return this;
        }


        /// <summary>
        /// Decrypts the ciphertext file using the age command.
        /// </summary>
        /// <returns>The builder instance for method chaining.</returns>
        public AgeTestBuilder DecryptWithAge()
        {
            if (AgeCommand == null)
            {
                throw new InvalidOperationException("age executable is not available");
            }

            if (_useAgeKeygen || _useDotAgeKeys)
            {
                // Decrypt using the private key
                RunProcess(AgeCommand, $"-d -i {_keyFile} -o {_decryptedFile} {_ciphertextFile}");
            }
            else if (_usePassphrase)
            {
                // Decrypt using the passphrase
                RunProcess(AgeCommand, $"-d -o {_decryptedFile} {_ciphertextFile}", _passphrase);
            }
            else
            {
                throw new InvalidOperationException("No decryption method configured");
            }

            return this;
        }

        /// <summary>
        /// Asserts that the decrypted content matches the original text content.
        /// </summary>
        public void AssertDecryptedTextContentMatches()
        {
            Assert.True(File.Exists(_decryptedFile), "Decrypted file should exist");
            Assert.Equal(_textContent, File.ReadAllText(_decryptedFile));
        }

        /// <summary>
        /// Asserts that the decrypted content matches the original binary content.
        /// </summary>
        public void AssertDecryptedBinaryContentMatches()
        {
            Assert.True(File.Exists(_decryptedFile), "Decrypted file should exist");
            var decryptedData = File.ReadAllBytes(_decryptedFile);
            Assert.Equal(_binaryContent, decryptedData);
        }

        /// <summary>
        /// Asserts that the specified exception is thrown when executing the action.
        /// </summary>
        /// <typeparam name="TException">The type of exception expected.</typeparam>
        /// <param name="action">The action to execute.</param>
        /// <param name="expectedMessage">The expected exception message (optional).</param>
        public void AssertThrows<TException>(Action action, string expectedMessage = null) where TException : Exception
        {
            var exception = Assert.Throws<TException>(action);
            if (expectedMessage != null)
            {
                Assert.Equal(expectedMessage, exception.Message);
            }
        }

        /// <summary>
        /// Cleans up all temporary files.
        /// </summary>
        public void Dispose()
        {
            CleanupFiles();
        }

        /// <summary>
        /// Deletes all temporary files.
        /// </summary>
        private void CleanupFiles()
        {
            foreach (var file in _filesToCleanup)
            {
                if (File.Exists(file))
                {
                    File.Delete(file);
                }
            }
        }

        /// <summary>
        /// Runs a process with the specified command and arguments.
        /// </summary>
        /// <param name="command">The command to run.</param>
        /// <param name="arguments">The arguments to pass to the command.</param>
        /// <param name="input">The input to provide to the process (optional).</param>
        /// <param name="timeoutSeconds">The timeout in seconds (default: 10).</param>
        private static void RunProcess(string command, string arguments, string input = null, int timeoutSeconds = 10)
        {
            var startInfo = new ProcessStartInfo
            {
                FileName = command,
                Arguments = arguments,
                RedirectStandardInput = true,
                RedirectStandardOutput = true,
                RedirectStandardError = true,
                UseShellExecute = false,
                CreateNoWindow = true
            };

            using var process = new Process { StartInfo = startInfo };

            // Set up asynchronous reading of output and error streams to prevent deadlocks
            var outputReader = new System.Threading.Tasks.Task<string>(() => process.StandardOutput.ReadToEnd());
            var errorReader = new System.Threading.Tasks.Task<string>(() => process.StandardError.ReadToEnd());

            process.Start();

            // Start reading from output and error streams
            outputReader.Start();
            errorReader.Start();

            if (!string.IsNullOrEmpty(input))
            {
                process.StandardInput.WriteLine(input);
                process.StandardInput.Close();
            }
            else
            {
                // Close standard input if no input is provided
                process.StandardInput.Close();
            }

            // Wait for the process to exit with timeout
            bool exited = process.WaitForExit(timeoutSeconds * 1000);

            if (!exited)
            {
                // Process did not exit within the timeout period, kill it
                process.Kill();
                throw new TimeoutException($"Process {command} {arguments} did not complete within {timeoutSeconds} seconds and was terminated.");
            }

            // Wait for the output and error readers to complete
            System.Threading.Tasks.Task.WaitAll(outputReader, errorReader);

            // Get the output and error
            var output = outputReader.Result;
            var error = errorReader.Result;

            if (process.ExitCode != 0)
            {
                throw new Exception($"Process exited with code {process.ExitCode}: {error}");
            }
        }

        /// <summary>
        /// Creates a file with random binary data of the specified size.
        /// </summary>
        /// <param name="sizeInBytes">The size of the file in bytes.</param>
        /// <returns>The path to the created file.</returns>
        private static string CreateRandomBinaryFile(int sizeInBytes)
        {
            var filePath = Path.Combine(Path.GetTempPath(), Path.GetRandomFileName());
            using var fileStream = new FileStream(filePath, FileMode.Create, FileAccess.Write);
            var random = new Random();
            var buffer = new byte[4096]; // Use a buffer for better performance

            int bytesRemaining = sizeInBytes;
            while (bytesRemaining > 0)
            {
                int bytesToWrite = Math.Min(buffer.Length, bytesRemaining);
                random.NextBytes(buffer);
                fileStream.Write(buffer, 0, bytesToWrite);
                bytesRemaining -= bytesToWrite;
            }

            return filePath;
        }

        /// <summary>
        /// Creates a file with text containing special characters.
        /// </summary>
        /// <returns>The path to the created file.</returns>
        private static string CreateSpecialCharactersFile()
        {
            var filePath = Path.Combine(Path.GetTempPath(), Path.GetRandomFileName());
            var specialChars = new StringBuilder();

            // Add various special characters and Unicode characters
            specialChars.AppendLine("Special characters test file");
            specialChars.AppendLine("---------------------------");
            specialChars.AppendLine("ASCII special: !@#$%^&*()_+-=[]{}|;':\",./<>?`~");
            specialChars.AppendLine("Quotes and escapes: \"quoted text\" and 'single quotes' and \\backslashes\\");
            specialChars.AppendLine("Unicode: ñáéíóúÑÁÉÍÓÚ");
            specialChars.AppendLine("Emoji: 😀 🚀 🌍 🎉 🔒");
            specialChars.AppendLine("Math symbols: ∑ ∫ ∏ √ ∂ π τ ∞ ∅ ∈ ∉ ∋ ⊂ ⊃ ∧ ∨ ∩ ∪");
            specialChars.AppendLine("Currency: $ € £ ¥ ₹ ₽ ₩");
            specialChars.AppendLine("Line breaks and tabs: Line1\nLine2\n\tTabbed line");

            File.WriteAllText(filePath, specialChars.ToString(), Encoding.UTF8);
            return filePath;
        }

        /// <summary>
        /// Finds the specified age executable (age or age-keygen) from the FiloSottile/age implementation.
        /// </summary>
        /// <param name="executableName">The name of the executable to find (age or age-keygen).</param>
        /// <returns>The full path to the executable, or null if not found.</returns>
        private static string FindAgeExecutable(string executableName)
        {
            // Paths to check for the FiloSottile/age executables
            var possibleAgePaths = new[]
            {
                // Common installation paths
                "/usr/local/bin",
                "/usr/bin",
                "/bin",
                // Homebrew paths
                "/opt/homebrew/bin",
                // Go paths
                Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), "go", "bin"),
                // Current directory and PATH
                Directory.GetCurrentDirectory()
            };

            // First check if the executable is in one of the possible paths
            foreach (var path in possibleAgePaths)
            {
                var fullPath = Path.Combine(path, executableName);
                if (File.Exists(fullPath))
                {
                    // Verify this is the FiloSottile/age implementation
                    if (IsFiloSottileAgeImplementation(fullPath))
                    {
                        return fullPath;
                    }
                }
            }

            // Then check if it's in the PATH
            var pathEnv = Environment.GetEnvironmentVariable("PATH");
            if (!string.IsNullOrEmpty(pathEnv))
            {
                var pathSeparator = Environment.OSVersion.Platform == PlatformID.Win32NT ? ';' : ':';
                var paths = pathEnv.Split(pathSeparator);

                foreach (var path in paths)
                {
                    var fullPath = Path.Combine(path, executableName);
                    if (File.Exists(fullPath))
                    {
                        // Verify this is the FiloSottile/age implementation
                        if (IsFiloSottileAgeImplementation(fullPath))
                        {
                            return fullPath;
                        }
                    }
                }
            }

            // If we get here, we couldn't find the executable
            return null;
        }

        /// <summary>
        /// Verifies that the specified age executable is from the FiloSottile/age implementation.
        /// </summary>
        /// <param name="executablePath">The path to the executable to verify.</param>
        /// <returns>True if the executable is from the FiloSottile/age implementation, false otherwise.</returns>
        private static bool IsFiloSottileAgeImplementation(string executablePath)
        {
            try
            {
                // Run the executable with the --version flag
                var process = new Process
                {
                    StartInfo = new ProcessStartInfo
                    {
                        FileName = executablePath,
                        Arguments = "--version",
                        RedirectStandardOutput = true,
                        RedirectStandardError = true,
                        UseShellExecute = false,
                        CreateNoWindow = true
                    }
                };

                process.Start();
                var output = process.StandardOutput.ReadToEnd();
                process.WaitForExit();

                // Check if the output contains "filippo.io/age", which is the import path for the FiloSottile/age implementation
                return output.Contains("filippo.io/age");
            }
            catch
            {
                return false;
            }
        }
    }
}
